<div><h1>
        togglable
    </h1>

    
    <hr> <!---->  <div class="uk-switcher"><!----> <div><!----> <!----> <!----> <h2>props:</h2> <div><!----> <table class="uk-table uk-table-striped"><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead> <tbody><tr style="opacity: 1;"><td><span>animation</span></td><td><span template="types"><span><span>list</span> <!----></span></span></td><td><span>Reveal item directly or with a transition.</span></td></tr> <tr style="opacity: 1;"><td><span>cls</span></td><td><span template="types"><span><a href="https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Boolean">Boolean</a> <!----></span></span></td><td><span>The class that is being toggled. Defaults to the hidden attribute.</span></td></tr> <tr style="opacity: 1;"><td><span>duration</span></td><td><span template="types"><span><a href="https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Number">Number</a> <!----></span></span></td><td><span>Animation duration in milliseconds.</span></td></tr> <tr style="opacity: 1;"><td><span>origin</span></td><td><span template="types"><span><a href="https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String">String</a> <!----></span></span></td><td><span></span></td></tr> <tr style="opacity: 1;"><td><span>queued</span></td><td><span template="types"><span><a href="https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Boolean">Boolean</a> <!----></span></span></td><td><span>Toggle the targets successively.</span></td></tr> <tr style="opacity: 1;"><td><span>transition</span></td><td><span template="types"><span><a href="https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String">String</a> <!----></span></span></td><td><span></span></td></tr> </tbody></table></div> <!----> <!----> <!----> <!----> <!----></div> <!----> <div><h2>code:</h2> <pre><code class="language-javascript">// import UIkit from '../api/index';
// import {$$, Animation, assign, attr, css, fastdom, hasAttr, hasClass, height, includes, isBoolean, isUndefined, isVisible, noop, Promise, toFloat, toggleClass, toNodes, Transition, trigger} from '../util/index';


/**
 *&nbsp;@file
 * @kind readme
 *
 * the toggleable can be explained in depth here!
 */

/**
 * @file
 * @type {UIkitComponent}
 */

export default {

    props: {
        /**
         * The class that is being toggled. Defaults to the hidden attribute.
         */
        cls: Boolean,
        /**
         * Reveal item directly or with a transition.
         */
        animation: 'list',
        /**
         * Animation duration in milliseconds.
         */
        duration: Number,
        /**
         *
         */
        origin: String,
        /**
         *
         */
        transition: String,
        /**
         * Toggle the targets successively.
         */
        queued: Boolean
    },

    defaults: {
        cls: false,
        animation: [false],
        duration: 200,
        origin: false,
        transition: 'linear',
        queued: false,

        initProps: {
            overflow: '',
            height: '',
            paddingTop: '',
            paddingBottom: '',
            marginTop: '',
            marginBottom: ''
        },

        hideProps: {
            overflow: 'hidden',
            height: 0,
            paddingTop: 0,
            paddingBottom: 0,
            marginTop: 0,
            marginBottom: 0
        }

    },

    computed: {

        hasAnimation({animation}) {
            return !!animation[0];
        },

        hasTransition({animation}) {
            return this.hasAnimation &amp;&amp; animation[0] === true;
        }

    },

    methods: {

        toggleElement(targets, show, animate) {
            return new Promise(resolve =&gt; {

                targets = toNodes(targets);

                const all = targets =&gt; Promise.all(targets.map(el =&gt; this._toggleElement(el, show, animate)));
                const toggled = targets.filter(el =&gt; this.isToggled(el));
                const untoggled = targets.filter(el =&gt; !includes(toggled, el));

                let p;

                if (!this.queued || !isUndefined(animate) || !isUndefined(show) || !this.hasAnimation || targets.length &lt; 2) {

                    p = all(untoggled.concat(toggled));

                } else {

                    const {body} = document;
                    const scroll = body.scrollTop;
                    const [el] = toggled;
                    const inProgress = Animation.inProgress(el) &amp;&amp; hasClass(el, 'uk-animation-leave')
                            || Transition.inProgress(el) &amp;&amp; el.style.height === '0px';

                    p = all(toggled);

                    if (!inProgress) {
                        p = p.then(() =&gt; {
                            const p = all(untoggled);
                            body.scrollTop = scroll;
                            return p;
                        });
                    }

                }

                p.then(resolve, noop);

            });
        },

        toggleNow(targets, show) {
            return new Promise(resolve =&gt; Promise.all(toNodes(targets).map(el =&gt; this._toggleElement(el, show, false))).then(resolve, noop));
        },

        isToggled(el) {
            const nodes = toNodes(el || this.$el);
            return this.cls
                ? hasClass(nodes, this.cls.split(' ')[0])
                : !hasAttr(nodes, 'hidden');
        },

        updateAria(el) {
            if (this.cls === false) {
                attr(el, 'aria-hidden', !this.isToggled(el));
            }
        },

        _toggleElement(el, show, animate) {

            show = isBoolean(show)
                ? show
                : Animation.inProgress(el)
                    ? hasClass(el, 'uk-animation-leave')
                    : Transition.inProgress(el)
                        ? el.style.height === '0px'
                        : !this.isToggled(el);

            if (!trigger(el, `before${show ? 'show' : 'hide'}`, [this])) {
                return Promise.reject();
            }

            const promise = (animate === false || !this.hasAnimation
                ? this._toggleImmediate
                : this.hasTransition
                    ? this._toggleHeight
                    : this._toggleAnimation
            )(el, show);

            trigger(el, show ? 'show' : 'hide', [this]);

            return promise.then(() =&gt; {
                trigger(el, show ? 'shown' : 'hidden', [this]);
                UIkit.update(el);
            });
        },

        _toggle(el, toggled) {

            if (!el) {
                return;
            }

            let changed;
            if (this.cls) {
                changed = includes(this.cls, ' ') || Boolean(toggled) !== hasClass(el, this.cls);
                changed &amp;&amp; toggleClass(el, this.cls, includes(this.cls, ' ') ? undefined : toggled);
            } else {
                changed = Boolean(toggled) === hasAttr(el, 'hidden');
                changed &amp;&amp; attr(el, 'hidden', !toggled ? '' : null);
            }

            $$('[autofocus]', el).some(el =&gt; isVisible(el) &amp;&amp; (el.focus() || true));

            this.updateAria(el);
            changed &amp;&amp; UIkit.update(el);
        },

        _toggleImmediate(el, show) {
            this._toggle(el, show);
            return Promise.resolve();
        },

        _toggleHeight(el, show) {

            const inProgress = Transition.inProgress(el);
            const inner = el.hasChildNodes ? toFloat(css(el.firstElementChild, 'marginTop')) + toFloat(css(el.lastElementChild, 'marginBottom')) : 0;
            const currentHeight = isVisible(el) ? height(el) + (inProgress ? 0 : inner) : 0;

            Transition.cancel(el);

            if (!this.isToggled(el)) {
                this._toggle(el, true);
            }

            height(el, '');

            // Update child components first
            fastdom.flush();

            const endHeight = height(el) + (inProgress ? 0 : inner);
            height(el, currentHeight);

            return (show
                ? Transition.start(el, assign({}, this.initProps, {overflow: 'hidden', height: endHeight}), Math.round(this.duration * (1 - currentHeight / endHeight)), this.transition)
                : Transition.start(el, this.hideProps, Math.round(this.duration * (currentHeight / endHeight)), this.transition).then(() =&gt; this._toggle(el, false))
            ).then(() =&gt; css(el, this.initProps));

        },

        _toggleAnimation(el, show) {

            Animation.cancel(el);

            if (show) {
                this._toggle(el, true);
                return Animation.in(el, this.animation[0], this.duration, this.origin);
            }

            return Animation.out(el, this.animation[1] || this.animation[0], this.duration, this.origin).then(() =&gt; this._toggle(el, false));
        }

    }

};
</code></pre></div> <!----> <!----> <!----></div> <hr> <i>package: <span></span></i> <!----></div>